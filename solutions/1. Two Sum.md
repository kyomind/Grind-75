# 2024-11-23 100
兩大重點
1. key一定是放值，value一定是放index，這樣才容易比較並找到index
2. 一定要先檢查再更新，不然會找到自己

---

#### 問題核心程式碼（提前更新 vs. 正確邏輯）
```python
# 提前更新
hash_map[n] = i
if target - n in hash_map:  # 嘗試查找配對
    return [hash_map[target - n], i]  # 錯誤：可能找到的是剛剛新增的數字
```

正確邏輯應該是：
```python
# 先檢查再更新
if target - n in hash_map:  # 檢查是否存在配對
    return [hash_map[target - n], i]
hash_map[n] = i  # 在沒有找到配對後，將當前數字新增到哈希表
```

---

### 為什麼提前更新會導致錯誤？
提前更新哈希表會將當前數字 `n` 自己加入哈希表，而程式馬上檢查是否存在與 `n` 配對的數字 `target - n`。這時候，如果目標配對數字恰好等於當前數字，程式會誤判它是自己與自己的配對。

舉例說明：

#### 錯誤邏輯（提前更新哈希表）
假設：
- `nums = [3, 2, 4]`
- `target = 6`

當遍歷到 `nums[0] = 3` 時：
1. 提前執行 `hash_map[3] = 0`，將數字 `3` 加入哈希表。
2. 檢查 `target - 3 = 3` 是否存在於哈希表：
   - 因為剛剛新增了 `3`，哈希表中有 `3: 0`。
3. 誤以為自己和自己匹配，返回 `[0, 0]`（錯誤）。

#### 正確邏輯（先檢查再更新哈希表）
同樣假設：
- `nums = [3, 2, 4]`
- `target = 6`

當遍歷到 `nums[0] = 3` 時：
1. 首先檢查 `target - 3 = 3` 是否存在於哈希表：
   - 此時，哈希表是空的，因此找不到，繼續執行。
2. 執行 `hash_map[3] = 0`，將數字 `3` 加入哈希表。
3. 繼續遍歷其他數字。

最終，當程式遍歷到 `nums[2] = 4` 時：
1. 檢查 `target - 4 = 2` 是否存在於哈希表：
   - 哈希表中有 `2: 1`，因此找到匹配，返回 `[1, 2]`。
