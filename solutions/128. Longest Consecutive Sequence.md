# 2025-01-02 200

使用 hash set
## 解題步驟（Longest Consecutive Sequence）
1. **將陣列轉換為集合（去重）**
   - 使用集合（Set）將輸入陣列去重，以便快速查找元素。
2. **尋找序列起始點**
   - 遍歷集合中的每個數字，檢查是否為序列的起始點（即 `num - 1` 不存在於集合中）。
3. **計算連續序列長度**
   - 對每個起始點：
     - 從 `num` 開始，依次檢查 `num + 1` 是否存在於集合中。
     - 每找到一個連續的數字，將序列長度加 1。
4. **記錄最長長度**
   - 更新一個全域變數 `max_length`，儲存最長的連續序列長度。
5. **返回結果**
   - 遍歷完成後，返回 `max_length` 作為最終結果。

### 關鍵重點
- **集合用於快速查找**，去除重複數字並提升效率。
- **起始點判斷條件**：`num - 1` 不在集合中。
- **符合 \(O(n)\) 時間複雜度**：每個數字最多被處理兩次。

---

## 雜湊表在此題的優化效果
1. **集合（Set）實現雜湊表**：
   - 在 Python 中，`set` 使用雜湊表來儲存元素，因此對 `in` 操作（檢查是否包含某個元素）具有 \(O(1)\) 的時間複雜度。
   - 程式中的以下操作受益於雜湊表的特性：
     ```python
     if num - 1 not in num_set:
     while current_num + 1 in num_set:
     ```
     這些查找操作可以在常數時間內完成，**而不是遍歷整個集合**。

### 如果沒有雜湊表，會怎樣？
如果沒有使用雜湊表（即集合 `set`），那麼：
1. **查找效率降低**：
   - 假設改用陣列來儲存數字，`if num - 1 not in num_set` 和 `while current_num + 1 in num_set` 將需要線性掃描整個陣列來確認是否存在某個數字。
   - 每次查找的時間複雜度為 \(O(n)\)，整體時間複雜度將變為 \(O(n^2)\)。

### 為什麼這樣設計是必要的？
雜湊表的作用是 **核心優化**：
- 它讓查找「某數是否存在」的操作從線性時間 \(O(n)\) 降到常數時間 \(O(1)\)。
- 因此，即使原始陣列包含數百萬個數字，程式也能在合理的時間內完成計算。

如果不使用雜湊表，這題**無法**在 \(O(n)\) 時間內解決，因為檢查連續性（如 `while current_num + 1 in num_set`）會變得非常低效。


## 先收集起始點再疊代計算，不會影響時間複雜度
>如果我等到先收集全部的起始點，再針對每個起始點進行疊代計算，這樣會影響時間複雜度嗎？

你的問題很有深度！如果改變實作方式，將「收集所有起始點」與「逐一針對起始點進行連續序列計算」分為兩步，對於時間複雜度而言，**不會有本質影響**，仍然是 \(O(n)\)。但實際執行效率和程式設計的優化可能會稍有不同。以下是詳細分析：

---

### 兩種實作方式的比較

#### **現有方式**：找到起始點後立刻進行疊代計算

- **特點**：
  - 每次發現起始點，當場計算連續序列長度，**沒有額外的空間需求。**
  - 時間複雜度為 \(O(n)\)，因為每個數字最多被處理兩次（一次檢查起始點，一次疊代計算序列）。

#### **改進方式**：先收集起始點，之後再逐一計算序列長度
- **過程**：
  1. 遍歷集合，將所有起始點儲存在一個列表（`starting_points`）。
     - 起始點條件：`num - 1 not in num_set`。
  2. 遍歷 `starting_points`，針對每個起始點進行疊代計算連續序列的長度。
  3. 更新全域最長長度。

- **特點**：
  - **需要額外的空間來儲存起始點列表**（大小最多為集合大小，空間複雜度為 \(O(n)\)）。
  - 時間複雜度**仍然是** \(O(n)\)，因為每個數字的檢查和疊代計算次數與原方法相同。

---

**其實結論就是兩者的差別非常小。**就只差在多出來的那個空間而已。