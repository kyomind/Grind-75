# 2025-02-09
## 本題重點
1. 二元搜尋的變形，變形的部分是**被搜尋的array是被旋轉過的**——不是完全有序的
2. 但**部分有序**，我們依舊可以利用這個特性來**一步步縮小搜尋範圍**

>簡單說，這一題因為有部分是無序的，所以在搜尋之後就**需要更細緻的處理**，我的理解正確嗎？
是的，你的理解正確。正因為旋轉導致部分無序，Binary Search 需要：
1. 先判斷哪一半是有序的
2. 根據有序那半的範圍決定接下來要往哪個方向搜尋

這就是為什麼程式碼中會多出判斷有序部分及其範圍的邏輯，而不是單純比較 `target` 和 `mid` 的大小。

## 不需要特別找到旋轉點★
這題的關鍵是：**無論陣列如何旋轉，一定會有一半是保持有序的。★★**

舉例說明：
```
原始：[1,2,3,4,5,6,7]
旋轉後：[4,5,6,7,1,2,3]
```

當我們取得 `mid=3` 時（值為 7）：
- 左半 [4,5,6,7]：有序
- 右半 [7,1,2,3]：無序

這時我們可以：
1. **先確認目標值是否在有序的那一半**→是的話就太讚了
2. 若不在，就往另一半繼續找

這種方式避免了直接尋找旋轉點的複雜度，而是利用「一半必定有序」的特性來縮小搜尋範圍。要注意的是邊界條件的處理，特別是當左右指針相鄰時的情況。


## 不夠充分的錯誤條件判斷
○其實也沒什麼，就是要判斷這個 target 在**這一個區間**的範圍之內而已，就這麼單純，**非常單純**
○原先的錯誤寫法就是因為**沒有寫出區間**，就**只有一個邊界**，那當然會是錯的

```python
if nums[left] < nums[mid]:
    # XXX 錯誤：if nums[left] <= target < nums[mid]:
    if target < nums[mid]:
        right = mid - 1
    else:
        left = mid + 1
```
主要錯誤在於判斷條件不夠完整：略
○而且其實這樣寫**超級直觀**的！Python萬歲！
```python
if nums[mid] < target <= nums[right]:
if nums[left] <= target < nums[mid]:
```

>為何 mid 都不用等號？
自問自答：**因為 mid 早就被檢查過了！**
```python
if nums[mid] == target:
    return mid
```


## 還有一個錯誤！
在判斷左側有序時，條件應該是 `nums[left] <= nums[mid]`，而不是 `nums[left] < nums[mid]`。

○我的看法很簡單，你要正確考慮到左邊到底有沒有序，你的 Left 跟 Mid 這兩個區間都一定要包含才行
○而另一邊 else 看似不需要包含，是因為你只要正確判斷好了左邊，那左邊有序無序就會知道右邊的正確性了

是的，這個理解非常準確：
1. 判斷左側是否有序需要比較「左邊界」和「中間點」，「=」需要包含以確保不漏掉任何情況
2. 一旦確定左側的狀態（有序/無序），右側的狀態就自動確定了，所以不需要額外的「=」判斷

這解釋了為什麼第一個條件需要 `<=`，而不是把「=」的情況留給 else。
