# 2025-02-09
## 本題重點
1. 二元搜尋的變形，變形的部分是**被搜尋的array是被旋轉過的**——不是完全有序的
2. 但**部分有序**，我們依舊可以利用這個特性來**一步步縮小搜尋範圍**

>簡單說，這一題因為有部分是無序的，所以在搜尋之後就**需要更細緻的處理**，我的理解正確嗎？
是的，你的理解正確。正因為旋轉導致部分無序，Binary Search 需要：
1. 先判斷哪一半是有序的
2. 根據有序那半的範圍決定接下來要往哪個方向搜尋

這就是為什麼程式碼中會多出判斷有序部分及其範圍的邏輯，而不是單純比較 `target` 和 `mid` 的大小。

## 不需要特別找到旋轉點★
這題的關鍵是：**無論陣列如何旋轉，一定會有一半是保持有序的。★★**

舉例說明：
```
原始：[1,2,3,4,5,6,7]
旋轉後：[4,5,6,7,1,2,3]
```

當我們取得 `mid=3` 時（值為 7）：
- 左半 [4,5,6,7]：有序
- 右半 [7,1,2,3]：無序

這時我們可以：
1. **先確認目標值是否在有序的那一半**→是的話就太讚了
2. 若不在，就往另一半繼續找

這種方式避免了直接尋找旋轉點的複雜度，而是利用「一半必定有序」的特性來縮小搜尋範圍。要注意的是邊界條件的處理，特別是當左右指針相鄰時的情況。


## 不夠充分的錯誤條件判斷
○其實也沒什麼，就是要判斷這個 target 在**這一個區間**的範圍之內而已，就這麼單純，**非常單純**
○原先的錯誤寫法就是因為**沒有寫出區間**，就**只有一個邊界**，那當然會是錯的

```python
if nums[left] < nums[mid]:
    # XXX 錯誤：if nums[left] <= target < nums[mid]:
    if target < nums[mid]:
        right = mid - 1
    else:
        left = mid + 1
```
主要錯誤在於判斷條件不夠完整：略
○而且其實這樣寫**超級直觀**的！Python萬歲！
```python
if nums[mid] < target <= nums[right]:
if nums[left] <= target < nums[mid]:
```

>為何 mid 都不用等號？
自問自答：**因為 mid 早就被檢查過了！**
```python
if nums[mid] == target:
    return mid
```


## 還有一個錯誤！而且很難立刻理解，先記得就好！
○因為這旋轉過，很難簡單就懂

在判斷左側有序時，條件應該是 `nums[left] <= nums[mid]`，而不是 `nums[left] < nums[mid]`。

這是因為：
- 當陣列中**有相等元素或只剩兩個元素**時，如 `[3,1]`，`left` 和 `mid` 可能指向相同的值
- 如果沒有 `=`，會導致判斷錯誤。

>那為何不能把帶有「=」的狀態丟給else處理，而是在if就要處理★★★
因為「=」的狀態可能會影響二分搜尋的準確性。

舉例：`[3,3,1]`，當 `left=0`、`mid=1` 時
- `nums[left] = 3`
- `nums[mid] = 1`
- `nums[right] = 3`
此時，左側是有序的，但如果我們用 `<` 來判斷，會錯誤地進入 else 分支，導致錯誤的搜尋範圍。
- 如果用 `<`：會錯誤地進入 else 分支
- 用 `<=`：能正確處理左側仍然有序的情況

所以 `<=` 是為了確保在有重複元素時，能正確識別有序的部分。

>好，我發現這個=，要完全理解why，並不容易，我的理解正確嗎？
是的，理解這個等號很微妙
它代表的不僅是單純的數值比較，而是在一個旋轉排序陣列中，幫助我們正確識別「真正有序」的那一側。

關鍵在於：當我們不能單純用數字大小來判斷有序時，這個等號能確保我們不會錯過可能的搜尋範圍。

我建議：**先掌握基本的二分搜尋邏輯，再理解這個等號的細節。這是一個進階的邊界處理問題。**
