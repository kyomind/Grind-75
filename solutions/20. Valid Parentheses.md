# 2024-11-27

寫到這裡就卡住了，顯然思路還沒打通

```Python
stack = []
for i in s:
    if i in ["{", "(", "["]:
        stack.append(i)
    else:
        # 這裡要怎麼寫？
```

---
## 低級錯誤——沒有呼叫方法！

> 不過這裡還要注意一點，`stack.pop` 是一個 in-place 方法，呼叫後會直接修改 `stack` 本身

你寫的程式有一個邏輯錯誤，主要是來自以下部分：

```python
if i == '}' and stack.pop == '{':
    continue
```

**問題點**：
1. **`stack.pop` 是方法而非操作結果**：
   - `stack.pop` 是一個方法，並不會在這裡執行彈出操作。
   - 當你寫 `stack.pop == '{'` 時，實際上比較的是方法本身，而不是從堆疊中彈出的值。

2. **堆疊元素彈出的方式錯誤**：
   - 正確的方式應該是使用 `stack.pop()`，這樣才能真正彈出堆疊頂端的元素並進行比較。

# 2025-02-06
## 為何pop時必須先檢查stack是否為空

主要有兩個原因：
1. 避免空堆疊存取錯誤
    * 當遇到右括號時，需要 `stack.pop()`
    * 若堆疊為空，`pop()` 會觸發 `IndexError`
    * `not stack` 先檢查避免程式崩潰
2. 邏輯正確性
    * 當堆疊為空但遇到右括號時，表示沒有左括號可配對
    * 例如：`s = ")"`，應該直接返回 `False`
    * 不檢查空堆疊會導致錯誤的配對邏輯

## 字典的話，key 必須是下括號，而 value 必須是上括號
是的，您的理解完全正確。用右括號作為 key 的原因：

1. 在檢查配對時，**我們拿到的是右括號**（如 `)`）
2. **我們需要快速查詢它對應的左括號**（如 `(`）
3. Dictionary 的 key → value 查詢效率為 O(1)
4. 若反過來，就需要額外處理 value → key 的查詢

所以把需要查詢的右括號作為 key，對應的左括號作為 value，是最直觀且高效的設計。
