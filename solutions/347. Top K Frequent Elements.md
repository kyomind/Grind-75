# 2025-01-03 200
這題的時間複雜度計算方式我覺得特別重要，heap法流程也相對明確

## 流程說明(Heap法)
1. **計算頻率（`dict` 自行計算）**：
   - 使用 `freq_map` 字典，遍歷 `nums` 陣列，對每個數字計數。
   - `freq_map` 最後會儲存每個數字和其對應的出現次數，例如：
     ```python
     nums = [1, 1, 1, 2, 2, 3]
     freq_map = {1: 3, 2: 2, 3: 1}
     ```

2. **使用小頂堆維護 `k` 個頻率最高的元素**：
   - 遍歷 `freq_map` 的 `items()`，將每組 `(頻率, 數字)` 推入 `heap`。
   - 當 `heap` 長度超過 `k` 時，從 `heap` 彈出最小元素，以維持堆中只有 `k` 個最高頻率元素。

3. **構建結果**：
   - 將 `heap` 中的數字提取出來，形成結果列表。

### 時間與空間複雜度

- **時間複雜度**： XXX
  - 計算頻率：`O(n)`，`n` 是 `nums` 長度。
  - 插入小頂堆：`O(n log k)`，每次插入操作代價為 `O(log k)`。 ○**這是建立heap的時間複雜度**
  - 總時間複雜度為 `O(n + n log k)`，簡化後為 `O(n log k)`。

- **空間複雜度**：
  - `freq_map` 佔用 `O(n)` 空間。
  - 堆大小為 `k`，佔用 `O(k)` 空間。
  - 總空間複雜度為 `O(n + k)`。 XXX
