# 2024-12-13
## ~~我反對使用 range() 來滑動視窗~~
### 結論
使用 **`while` 雙指標寫法** 不僅強調了 **Two Pointers** 的邏輯，還讓程式碼更易於理解和轉換到其他語言。這種寫法更加通用且符合面試場景的需求，建議優先使用！
### 2025-02-05 好吧，其實用range也是有它的好處的
好處是不必手動移動指標，這樣可以減少一些錯誤
只是不通用而已
### 又看了一次，我覺得while寫法也是挺難懂的

# 2025-02-05 使用 array 或 dict 來計數的差別
## 1. array
讓我展示將字串 "xyz" 轉換成字符頻率計數陣列的過程：

```python
# 初始化計數陣列
count_s1 = [0] * 26

# 原始字串
s1 = "xyz"

# 轉換過程
for char in s1:
    index = ord(char) - ord('a')  # 最重要的一行
    count_s1[index] += 1

print(count_s1)  # [0, 0, 0, ..., 1, 1, 1, ..., 0]
```
解釋這個計數陣列：
* 長度為 26 的陣列對應 a-z
* x 的 index = ord('x') - ord('a') = 23
* y 的 index = ord('y') - ord('a') = 24
* z 的 index = ord('z') - ord('a') = 25

## 2. dict
不過需要注意，**當計數為 0 時要刪除該鍵值，這樣才能正確比較兩個字典是否相等。**
雖然實作更直觀，但在時間和空間複雜度上，兩種方法其實是相似的。選擇哪種方法主要取決於程式碼的可讀性和維護性的需求。

# 我覺得本題最難的地方，在於滑動視窗這個行為的控製程式碼。
您說得對，讓我針對滑動視窗的控制邏輯進行更深入的分析。

**滑動視窗的核心操作可以分解為三個重要階段：**

1. 初始化視窗
```python
# 取出與 s1 相同長度的子串進行初始化
for i in range(len(s1)):
    count_s2[s2[i]] = count_s2.get(s2[i], 0) + 1
```

2. 視窗滑動
```python
# 從 len(s1) 開始，因為前面的位置已經在初始化時處理過
for i in range(len(s1), len(s2)):
    # i 代表視窗右邊界的新位置
    # i - len(s1) 代表視窗左邊界要移除的位置
```

3. 視窗更新
```python
# 這兩個操作必須同時進行
new_char = s2[i]                    # 加入右邊新進入的字符
old_char = s2[i - len(s1)]         # 移除左邊離開的字符
```

理解這個過程的關鍵在於：
- 視窗大小固定為 `len(s1)`
- 透過 `i - len(s1)` 計算左邊界
- 每次移動都是一個字符的距離
- 視窗的移動是連續的，沒有跳躍

這種實作方式確保了我們能夠系統性地檢查 s2 中的每個可能的子串，而不會遺漏或重複。使用這種滑動視窗的技巧，我們實際上是在 O(n) 的時間內完成了所有可能子串的檢查，這比暴力法要高效得多。
