# 2024-11-30
本題的解法是使用遞迴的方式，將左右子樹交換，然後再將左右子樹的左右子樹交換，以此類推。
這是遞迴+**後序遍歷**的應用

**本題自己實作比我想像中的不直觀 無法第一次就寫出來。**
機器輔助把一切都變得太理所當然了


## 錯誤寫法

```python
class Solution:
    def invertTree(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: Optional[TreeNode]
        """
        if root is None:
            return None

        while root:
            # 注意這裡要調換的是root的節點，不要寫成self.left..
            self.invertTree(root.right)
            self.invertTree(root.left)
            root.right, root.left = root.left, root.right

        return root
```

這段程式碼的邏輯有幾個問題，導致它無法正確地反轉二元樹。以下是詳細分析：

---

### 問題 1：**`while root` 不必要且錯誤**
- **錯誤原因**：
  - 在這裡使用 `while root` 是不合適的，因為**這不是標準的遞迴結構**。`while` 會讓程式進入無限迴圈或跳過正確的遞迴流程。
  - 正確的遞迴結構應該是針對左右子樹進行遞迴呼叫，而不應使用 `while`，因為 `while` 會無條件重複執行，和遞迴的概念衝突。

- **修正建議**：
  - 刪除 `while root`，因為遞迴本身已經會遍歷樹的所有節點。

---

### 問題 2：**交換左右子樹的位置錯誤**
- **錯誤原因**：
  - 交換左右子樹的操作 `root.right, root.left = root.left, root.right` 被放置在遞迴調用之後，這會導致交換在子樹反轉完成後進行，而應該在子樹遞迴之前進行交換。
  - 因為**遞迴調用的順序是自頂向下的，交換應該發生在對子樹進行處理之前**，否則左右子樹的反轉將會錯誤地互相覆蓋。

- **修正建議**：
  - 將交換操作移到遞迴呼叫之前。

---

### 修正後的程式碼
(略，就是我第一種寫法)

## 另一種類似的寫法(kyo: 僅參考但真的第一種比較好理解)
>為何這個寫法也行？兩者看起來不盡相同，差別究竟在哪？（兩者都可以通過，但看起來有所不同）
```python
class Solution:
    def invertTree(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: Optional[TreeNode]
        """
        if root is None:
            return None

        # 遞迴先反轉左右子樹
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)

        # 然後交換左右子樹
        root.left, root.right = right, left

        return root
```
這兩個版本的寫法確實有所不同，但都能正確地解決問題，因為它們遵循了正確的遞迴邏輯。
以下是兩者的主要差異以及為什麼它們都可以工作。

---

### 差異點分析

| 版本 | 遞迴處理順序 | 交換位置 | 優點與特徵 |
|------|-------------|----------|------------|
| **版本 1** (交換在遞迴之前)： | 遞迴呼叫時，子樹已經被交換 | **交換左右子樹在遞迴之前** | 邏輯更直觀，因為交換和遞迴的過程是分開的。適合直接理解反轉操作。 |
| **版本 2** (交換在遞迴之後)： | 遞迴呼叫時，子樹還是原始結構 | **交換左右子樹在遞迴之後** | 更清楚地表達「先遞迴處理子樹，後處理當前節點」，表現出後序遍歷的特性。 |

---

### 為什麼兩者都能正確運作？

#### **版本 1：交換在遞迴之前**
1. **交換左右子樹**：
   - 先對當前節點的左右子樹進行交換。
2. **遞迴調用**：
   - 再對交換後的左右子樹進行遞迴反轉。
3. **返回根節點**：
   - 經過遞迴後，返回反轉完成的根節點。

這種方式的特點是：交換操作發生在遞迴之前，左右子樹在進行遞迴時已經是被交換的狀態，因此整體流程上偏向直覺的「先交換，再處理子樹」。

#### **版本 2：交換在遞迴之後**
1. **遞迴處理子樹**：
   - 先遞迴地反轉左子樹和右子樹，分別獲得新的左右子樹（`left` 和 `right`）。
2. **交換左右子樹**：
   - 在處理完左右子樹後，將左右子樹的結果交換。
3. **返回根節點**：
   - 將交換完成的根節點返回。

這種方式的特點是：左右子樹的反轉發生在交換操作之前，表現了「後序遍歷」的特性，即「處理子節點後再處理當前節點」。

---

### 關鍵差別：交換時的左右子樹狀態
- **版本 1（交換在遞迴之前）**：
  - 遞迴時處理的是已經交換過的子樹。
  - 遞迴處理的順序和最終樹的形狀一致。
- **版本 2（交換在遞迴之後）**：
  - 遞迴時處理的是未交換的原始子樹，交換發生在最後一步。
  - 更符合處理順序「先遞迴解決小問題，再解決當前問題」。

兩者的交換位置不同，導致遞迴時左右子樹的結構不同，但由於交換最終會正確更新到根節點，因此結果一致。

---

### 優劣比較

| 特性                     | **版本 1（交換在遞迴之前）** | **版本 2（交換在遞迴之後）** |
|--------------------------|-----------------------------|-----------------------------|
| **可讀性**                | 較直觀，交換操作先於遞迴執行 | 更抽象，先遞迴後交換 |
| **邏輯順序**              | 偏向「先處理當前節點，再處理子節點」 | 更像後序遍歷的順序 |
| **實際效能（時間/空間）** | 相同，時間 O(n)，空間 O(h)   | 相同，時間 O(n)，空間 O(h)   |
| **理解難度**              | 對初學者更友善              | 對遞迴邏輯要求稍高         |

---

### 總結
兩個版本的主要差別在於交換操作的位置：
- **版本 1**：交換在遞迴之前，先交換後處理子樹，邏輯直觀。
- **版本 2**：交換在遞迴之後，先處理子樹後交換，符合後序遍歷的自然流程。

哪個更好取決於你的偏好與熟悉程度。
- 如果你對遞迴結構非常熟悉，**版本 2** 更加通用，因為它更符合遞迴處理問題的邏輯。
- 而對於初學者，**版本 1** 更容易理解，因為它**將交換與遞迴分開處理**。
