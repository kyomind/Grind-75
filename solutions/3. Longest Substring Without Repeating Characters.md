# 2025-02-02
while 是可能**連續執行**超過2 次的。這個例子就會："abcc"，3次

當我們討論「while 迴圈連續執行次數」時，實際上是在問：當發現目前的字元 s[right] 在滑動視窗中已經存在時，**我們需要移除多少個位於左側的字元，才能把這個重複的字元從 set（滑動視窗）中移除**，從而允許把當前字元加入。

這個連續執行的次數正好等於從目前 left 指標的位置開始，到先前那個重複字元的位置（含該重複字元）需要移除的字元數。換句話說，如果先前重複字元的位置是 i（且 i ≥ left），那麼 while 迴圈在該次執行中會連續執行 i − left + 1 次。

> 4、5、6次的簡單舉例
abcdd、abcdee、abcdeff
只是這看起來還是受到了字母英文的上限，但不重要

不要太執行於可能的次數，重點並不在此，而是在於**如何處理重複字元**。

# 2024-12-11

## 第一次對話精華整理

> 請你再舉一個例子，這個字串不需要太長，但必須讓 Left 移動兩次。

非常好的問題！你抓住了滑動視窗法中的一個關鍵點。讓我們用一個簡短的例子來展示 `left` 需要多次移動的情況。

### 例子：`s = "abba"`

在這個例子中，當我們遇到第二個 `b` 時，`left` 需要移動兩次才能確保視窗中不再有重複字符。

### 步驟解析

1. 初始狀態：
   - `left = 0`
   - `right = 0`
   - `char_set = {}`（空集合）
   - `max_length = 0`

2. `right = 0`，字符 `s[right] = 'a'`：略過。
3. `right = 1`，字符 `s[right] = 'b'`：略過。

4. `right = 2`，字符 `s[right] = 'b'`（第二個 `b`）：★
   - `b` 已經在 `char_set` 中，這說明有重複字符，因此進入 `while` 迴圈開始移動 `left`。

   - **第一次 `left` 移動**：
     - 移除 `s[left] = 'a'`（索引 `0`）從 `char_set` 中，然後將 `left` 移到 `1`。
     - 現在 `char_set = {'b'}`。
     - 檢查 `s[right] = 'b'` 是否還在 `char_set` 中，發現 `b` 還在，說明還有重複字符，因此 `while` 迴圈繼續執行。

   - **第二次 `left` 移動**：
     - 移除 `s[left] = 'b'`（索引 `1`）從 `char_set` 中，然後將 `left` 移到 `2`。
     - 現在 `char_set = {}`（空集合）。
     - 此時 `s[right] = 'b'` 不在 `char_set` 中，`while` 迴圈結束。

   - 將 `b` 加入 `char_set` 中，現在 `char_set = {'b'}`。
   - 更新 `max_length = max(2, 2 - 2 + 1) = 2`（最大長度不變）。

5. **`right = 3`，字符 `s[right] = 'a'`**：
   - `a` 不在 `char_set` 中，因此將 `a` 加入 `char_set`。
   - 更新 `max_length = max(2, 3 - 2 + 1) = 2`。
   - 狀態：`char_set = {'a', 'b'}`, `left = 2`

### 總結

在這個例子中，當 `right = 2` 指向第二個 `b` 時，我們需要連續移動 `left` 兩次才能將重複的 `b` 移出視窗。這就是 `left` 在同一個 `right` 位置需要移動多次的情況。

### 為什麼 `left` 會移動多次？

這個例子展示了當視窗內有多個重複字符時，`left` 必須連續移動多次直到去除所有重複字符，才能保證當前視窗內的所有字符唯一。這是 `while` 迴圈存在的意義：當有重複字符時，`left` 需要連續移動，直到視窗內的字符重新變得唯一。

希望這個例子能幫助你理解為什麼 `left` 會在同一次 `for` 迴圈中移動多次！

> 我懂了，因為**重複值可能出現在整個子字母的中間或後段**，此時 left 指針**要移動到該位置，需要多次移動！**
> **只需移動一次**的情況，是重複**剛好出現在子字串第一個位置**的時候，我的理解正確嗎？→yes


## **為什麼必須 `remove`？**

1. **集合 `char_set` 的作用**
   集合 `char_set` 是用來 **記錄當前視窗內的字元**。當滑動視窗右邊界 (`right`) 擴展時，若遇到重複字元，必須調整左邊界 (`left`) 來排除重複，讓視窗內維持字元唯一性。

2. **如果不 `remove`，會發生什麼？**
   - 如果不從集合中移除字元，集合會持續包含重複字元。
   - 這樣在檢查 `s[right] in char_set` 時，條件永遠無法通過，`while` 迴圈會陷入死循環或邏輯錯誤。
   - 例如當 `left` 不斷右移時，滑動視窗範圍會錯誤地包含重複字元，導致結果不正確。

> 講白了就是**為了脫離while迴圈，必須remove，否則會一直重複判斷，無法跳出迴圈。**

```python
while char in char_set:
   # XXX 必須移除的解說請看文件
   char_set.remove(s[left])
   left += 1
```

我會有這個疑問是因為，**沒幾行之後就會把這個元素加回去，所以覺得很懷疑。**
但現在我知道為什麼了，**其實只是為了脫離當前迴圈**，僅此而已！
